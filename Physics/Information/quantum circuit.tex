\documentclass[hyperref, UTF8, a4paper]{ctexart}

\usepackage{geometry}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{paralist}
\usepackage{footnote}
\usepackage{enumerate}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{bbm}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{physics}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{autobreak}
\usepackage[ruled, vlined, linesnumbered, noend]{algorithm2e}
\usepackage[colorlinks, linkcolor=black, anchorcolor=black, citecolor=black]{hyperref}
\usepackage{prettyref}

% Page style
\geometry{left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
\titlespacing{\paragraph}{0pt}{1pt}{10pt}[20pt]
\setlength{\droptitle}{-5em}
\preauthor{\vspace{-10pt}\begin{center}}
\postauthor{\par\end{center}}

% Math operators
\DeclareMathOperator{\timeorder}{T}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\legpoly}{P}
\DeclareMathOperator{\primevalue}{P}
\DeclareMathOperator{\sgn}{sgn}
\newcommand*{\ii}{\mathrm{i}}
\newcommand*{\ee}{\mathrm{e}}
\newcommand*{\const}{\mathrm{const}}
\newcommand*{\comment}{\paragraph{注记}}
\newcommand*{\suchthat}{\quad \text{s.t.} \quad}
\newcommand*{\argmin}{\arg\min}
\newcommand*{\argmax}{\arg\max}
\newcommand*{\normalorder}[1]{: #1 :}
\newcommand*{\pair}[1]{\langle #1 \rangle}
\newcommand*{\fd}[1]{\mathcal{D} #1}
\DeclareMathOperator{\bigO}{\mathcal{O}}

% prettyref setting
\newrefformat{sec}{第\ref{#1}节}
\newrefformat{note}{注\ref{#1}}
\newrefformat{fig}{图\ref{#1}}
\newrefformat{alg}{算法\ref{#1}}
\renewcommand{\autoref}{\prettyref}

% TikZ setting
\usetikzlibrary{arrows,shapes,positioning}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.markings}
\tikzstyle arrowstyle=[scale=1]
\tikzstyle directed=[postaction={decorate,decoration={markings,
    mark=at position .5 with {\arrow[arrowstyle]{stealth}}}}]
\tikzstyle ray=[directed, thick]
\tikzstyle dot=[anchor=base,fill,circle,inner sep=1pt]

% Algorithm setting
\renewcommand{\algorithmcfname}{算法}
% Python-style code
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif:}{else:}{}
\SetKwFor{For}{for}{:}{}
\SetKwFor{While}{while}{:}{}
\SetKwInput{KwData}{输入}
\SetKwInput{KwResult}{输出}
\SetArgSty{textnormal}

\renewcommand{\emph}[1]{\textbf{#1}}
\newcommand*{\concept}[1]{\underline{\textbf{#1}}}
\newcommand*{\Ztwo}{$\mathbb{Z}_2$}

\title{量子比特系统和量子逻辑电路}
\author{吴何友}

\begin{document}

\maketitle

\section{量子比特系统}

\subsection{单量子比特}

一个\concept{单量子比特系统}是一个只有$\ket{0}$和$\ket{1}$两种状态的系统。
正如经典比特系统非常简单，但是可以编码一切经典信息，量子比特系统也是量子计算的基础。
单个量子比特也可以看成一个$1/2$自旋自由度，虽然未必有对应的对称性。

量子比特系统的密度矩阵是本征值之和为$1$、本征值大于等于零的全体$2 \times 2$复厄米矩阵，容易验证这样的矩阵一定具有形式
\begin{equation}
    \hat{\rho} = \frac{1 + \vb*{r} \cdot \hat{\vb*{\sigma}}}{2} = \frac{1 + x \hat{\sigma}_x + y \hat{\sigma}_y + z \hat{\sigma}_z}{2}, \quad r = \sqrt{x^2+y^2+z^2} \leq 1.
    \label{eq:bloch-ball}
\end{equation}
这是因为泡利矩阵构成全体$2\times 2$厄米矩阵的一组基，于是一个$2\times 2$厄米矩阵一定可以写成
\[
    R(1 + x \hat{\sigma}_x + y \hat{\sigma}_y + z \hat{\sigma}_z)
\]
的形式。这样的矩阵的本征值为$R(1 \pm r)$，而为了保证本征值之和为$1$必须取$R=1/2$，由本征值大于等于零就有$r\leq 1$，于是就得到\eqref{eq:bloch-ball}。

可以看出，$\vb*{r}$的取值范围构成了一个半径为$1$的球，称为\concept{Bloch球}。
任何密度矩阵都可以表示成Block球上的一个点。
当且仅当密度矩阵只有一个本征值非零时，它对应一个纯态，因此量子比特系统是纯态，当且仅当$r=1$，而$r<1$的情况都是混合态。
实际上，通过计算冯诺依曼熵可以发现$r$越大熵越小，$r=0$时是完全混和态。
于是Bloch球的球壳上是全部纯态，其内部为全部混合态。

既然所有纯态都在Bloch球的球面，不失一般性地，以$z$轴和Bloch球的交点为$\ket{0}$，我们很快会发现$\ket{1}$对应的是$(x, y, z) = (0, 0, -1)$，因此$\ket{0}$在Bloch球的北极，而$\ket{1}$在Bloch球的南极。
显然，$\ket{0}$和$\ket{1}$没有任何特殊地位，因此我们得出结论：Bloch球球面上相对的两个点表示一对正交态。

在Bloch球上建立球坐标系，以$(r, \theta, \varphi)$为球坐标。对$r=1$的点，即纯态，代入\eqref{eq:bloch-ball}，做特征分解可以得到
\begin{equation}
    \ket{\psi(\vb*{r})} = \cos \frac{\theta}{2} \ket{0} + \sin \frac{\theta}{2} \ee^{\ii \varphi} \ket{1},
\end{equation}
而与它正交、位于Bloch球另一边的$\ket{\psi(-\vb*{r})}$是
\begin{equation}
    \ket{\psi(-\vb*{r})} = \sin \frac{\theta}{2} \ket{0} - \cos \frac{\theta}{2} \ee^{\ii \varphi} \ket{1}.
\end{equation}

Bloch球以一种直观的方式展现了量子比特系统和经典比特系统的区别：一个经典比特系统只能够存储\SI{1}{bit}的信息，但是一个量子比特系统需要两个实数来描述，因此包含不可数无穷多个比特的信息。
但是这里有一个微妙的地方：态矢量的分量系数并不是直接可以实验观察的，但一旦做了观测，量子比特系统就坍缩了。
因此我们并不能将$\theta$和$\varphi$直接读出来。

\subsection{多量子比特}

\begin{equation}
    \hat{\rho}_{AB} = \frac{1}{4} (1 + \vb*{a} \cdot \hat{\vb*{\sigma}} \otimes 1_B + 1_A \otimes \vb*{b} \cdot \hat{\vb*{\sigma}} + \sum_{jk} T_{jk} \hat{\sigma}_j \otimes \hat{\sigma}_k ).
\end{equation}

\subsection{量子比特系统的制备}

\section{量子关联}

本节讨论量子比特系统展现出的一些纠缠特性。% TODO:与量子密钥分发之间的关系

\subsection{CHSH游戏}

\concept{CHSH游戏}指的是这样一个过程：一个真随机数发生器产生一对均匀分布、彼此无关的比特$x$和$y$，将它们分别提供给Alice和Bob，两人相距一段距离，彼此不能联系，然后Alice和Bob分别产生一个比特，记作$a$和$b$，如果
\begin{equation}
    x \land y = a \oplus b,
\end{equation}
游戏就成功了。

当然，Alice和Bob可以采取不同的策略来增大游戏成功的概率，不过显然游戏成功的概率有一个小于$1$的上限。我们将指出，如果量子力学实际上是错误的，也即，可以用局域的隐变量模拟各种量子现象，那么游戏成功的概率的上限要小于量子力学实际上成立时的概率上限。
这意味着量子力学的一部分不同诠释实际上有可观察的效应。

由于$x$和$y$是均匀分布且彼此独立的，有
\begin{equation}
    \begin{aligned}
        P_\text{win} &= \sum_{a, b, x, y} V(x, y, a, b) p_{AB|XY}(a, b | x, y) p_{XY}(x, y) \\
        &= \frac{1}{4} \sum_{a, b, x, y} V(x, y, a, b) p_{AB|XY}(a, b | x, y).
    \end{aligned}
\end{equation}
其中$V(x, y, a, b)$是指示函数，在游戏成功时为$1$，否则为$0$。现在要做的就是分析$p_{AB|XY}(a, b | x, y)$的形式。

\subsubsection{隐变量理论的上限}

Alice和Bob在分开之前可能有某种约定，从而导致它们在分开之后看起来还是有远距离关联，这是隐变量理论模拟量子纠缠的思路。
我们取一个非常一般化的形式：设有隐变量为$\Lambda$，且
\[
    p_{AB|XY}(a, b | x, y) = \int \dd{\lambda} p_\Lambda(\lambda) p_{A|\Lambda X} (a | \lambda, x) p_{B|\Lambda Y}(b | \lambda, b).
\]
由于Alice和Bob分开之后才根据$x, y$决定$a, b$，$a$和$b$的产生是彼此独立的，因此我们有上式的形式。
这样
\[
    \begin{aligned}
        P_\text{win} &= \int \dd{\lambda} p_\Lambda(\lambda) \frac{1}{4} \sum_{a, b, x, y} V(x, y, a, b) p_{A|\Lambda X} (a | \lambda, x) p_{B|\Lambda Y}(b | \lambda, b) \\
        &\leq \frac{1}{4} \sum_{a, b, x, y} V(x, y, a, b) p_{A|\Lambda X} (a | \lambda^*, x) p_{B|\Lambda Y}(b | \lambda^*, b),
    \end{aligned}
\]
不等号是因为对$\lambda$的积分无非是一种平均值，因此只需要适当调节$\lambda^*$就可以让被积函数大于最后的积分值，且等号可以取到。
这意味着隐变量其实在此处并没有什么意义——最有效的策略中隐变量是定死的。更进一步，我们可以发现让只有$x, y, a, b$能够胜利时概率取$1$其它情况取$0$能够获得最大胜率，因此胜率最大的策略中$a$是$x$的函数，而$b$是$y$的函数。
这意味着我们需要让
\[
    0 = a_1 \oplus b_0, \quad 0 = a_0 \oplus b_1, \quad 0 = a_0 \oplus b_0, \quad 1 = a_1 \oplus b_1
\]
尽可能成立。这四个式子不能都成立，最多只能成立三个，否则会产生矛盾，于是我们会发现$P_\text{win}$最大为$3/4$。

\subsubsection{量子关联的胜率上限}

另一方面，如果标准的量子力学的纠缠态是可以实现的，我们将会获得比$3/4$更大的胜率上界。
这里不再使用隐变量来编码Alice和Bob的关联，而是真的认为Alice和Bob组成的系统由一个密度矩阵$\hat{\rho}$描述。
这覆盖了隐变量的机制，同时还允许真正的量子纠缠，即所谓密度矩阵的非对角部分。

由于$x, y$是给定的，Alice和Bob可以根据他们得到的确定的$x, y$值来分别决定给出什么输出。
唯一能够试图利用他们之间的关联的方法是通过测量$\hat{\rho}$，于是
\[
    p_{AB|XY}(a, b | x, y) = \trace (\hat{\rho} \hat{\Pi}_{a}^{(x)} \otimes \hat{\Pi}_{b}^{(y)}),
\]
其中诸$\hat{\Pi}$均为正定算符，是POVM测量的测量算符，且满足归一化条件。
最大值肯定是在$\hat{\rho}$代表纯态时取到的，因为测量算符是正定的。因此接下来我们讨论纯态的情况，即
\[
    p_{AB|XY}(a, b | x, y) = \mel{\phi}{\hat{\Pi}_{a}^{(x)} \otimes \hat{\Pi}_{b}^{(y)}}{\phi}.
\]

最大纠缠态时取到等号。
所谓的\concept{Tsirelson不等式}。

因此，如果量子纠缠真的是物理可实现的，我们将会观察到胜率高于$3/4$的情况。

\subsection{贝尔实验}

CHSH游戏可以一般化为这样一个场景：

\section{量子电路模型}

正如基于经典比特系统的经典逻辑电路可以实现经典计算机，基于量子比特系统的\concept{量子电路}也可以实现量子计算机。
此处“电路”一词并不代表我们使用电子系统实现量子比特，而只是为了和经典构成对比。

一个量子电路模型通常可以分为三步：
\begin{enumerate}
    \item 制备量子态，包括但不限于根据（可能是经典的）输入制备量子比特和引入辅助位；
    \item 幺正演化，即让量子比特经过一系列幺正矩阵（\concept{量子逻辑门}）的变换；
    \item 测量。我们通常将测量放在最后，因为可以根据\concept{推迟测量原则}，任何在计算过程中发生的测量都可以推迟到线路的最后。
\end{enumerate}

\subsection{量子逻辑门}

\subsubsection{单量子比特门}

单比特操作是非常容易实现的，但是显然是不够的，因为多量子比特系统经过单比特操作之后一定会得到直积态，而不能产生纠缠态。

最容易想到的量子门包括泡利矩阵，我们分别用$X, Y, Z$指代三个方向上的泡利矩阵，这样就获得了三个门。
除此以外还有更多的门，如\concept{Hadamard门}是指
\begin{equation}
    H = \frac{1}{\sqrt{2}} \pmqty{1 & 1 \\ 1 & -1},
\end{equation}
它可以用于实现态叠加。
\concept{相位门}是指
\begin{equation}
    S = \pmqty{1 & 0 \\ 0 & \ii},
\end{equation}
它可以在单个量子比特的两种可能本征态之间产生一个$\pi/2$的相对相位。
有了$\pi/2$相位当然还可以有别的相位，如\concept{T门}或者\concept{$\pi/8$门}
\begin{equation}
    T = \pmqty{1 & 0 \\ 0 & \exp(\ii \pi / 4)}.
\end{equation}

单量子比特逻辑门有通用的构造方法。我们有\concept{旋转}
\begin{equation}
    R_x(\theta) = \exp(-\frac{\ii \theta X}{2}) = \pmqty{ \cos \frac{\theta}{2} & - \ii \sin \frac{\theta}{2} \\ - \ii \sin \frac{\theta}{2} & \cos \frac{\theta}{2} },
\end{equation}
\begin{equation}
    R_y(\theta) = \exp(-\frac{\ii \theta Y}{2}) = \pmqty{ \cos \frac{\theta}{2} & - \sin \frac{\theta}{2} \\ \sin \frac{\theta}{2} & \cos \frac{\theta}{2} },
\end{equation}
\begin{equation}
    R_z(\theta) = \exp(-\frac{\ii \theta Z}{2}) = \pmqty{\dmat{\ee^{- \frac{\ii \theta}{2}}, \ee^{\frac{\ii \theta}{2}}}}.
\end{equation}
实际上，更加一般的，绕着轴$\vb*{n}$的旋转门为
\begin{equation}
    R_{\vb*{n}}(\theta) = \cos \frac{\theta}{2} I - \ii \sin \frac{\theta}{2} \vb*{n} \cdot \hat{\vb*{\sigma}}.
\end{equation}
可以证明，任何一个单比特幺正变换均形如
\begin{equation}
    U = \ee^{\ii \alpha} R_z(\beta) R_y(\gamma) R_z(\delta) = \pmqty{ \ee^{\ii (\alpha - \beta/2 - \delta / 2)} \cos \frac{\gamma}{2} & - \ee^{\ii (\alpha - \beta/2 + \delta / 2)} \sin \frac{\gamma}{2} \\ \ee^{\ii (\alpha + \beta/2 - \delta / 2)} \sin \frac{\gamma}{2} & \ee^{\ii (\alpha + \beta/2 + \delta / 2)} \cos \frac{\gamma}{2} },
\end{equation}
因此写出了单量子比特变换之后可以用三个旋转门连同一个一般的相位门来实现它。
这个一般形式没有用到$R_x$门，但是这并没有什么奇怪的——实际上它就是欧拉角。
上式的分解有一个简单的变形。设
\begin{equation}
    A = R_z(\beta) R_y \left( \frac{\gamma}{2} \right), \quad B = R_y\left( - \frac{\gamma}{2} \right) R_z\left( - \frac{\delta + \beta}{2} \right), \quad C = R_z\left( \frac{\delta - \beta}{2} \right),
    \label{eq:abc-decomposition}
\end{equation}
则
\begin{equation}
    U = \ee^{\ii \alpha} A X B X C, \quad ABC = I.
\end{equation}
这个结论在实现受控$U$门时可以用到。

我们有以下简单的逻辑门恒等式：
\begin{equation}
    H = (X + Z) / \sqrt{2},
\end{equation}
\begin{equation}
    H X H = Z, \quad H Z H = X, H Y H = - Y.
\end{equation}

\subsubsection{受控门}

最为平凡的二量子比特门可能是两个单量子比特门直积得到的（注意张量积不可交换，虽然$A \otimes B \simeq B \otimes A$）。
仅仅靠门的直积不能得到所有可能的量子逻辑门，因为这样不能产生纠缠态。

稍微复杂一些的二量子比特门是所谓\concept{受控操作}，即只有在某个量子比特（称为\concept{控制位}）为$1$时才对另一个量子比特（称为\concept{目标位}）做操作。物理地说，受控门的作用是产生纠缠，原因是显然的——它对应量子比特之间的相互作用。
CNOT是一个典型的受控门，它形如
\begin{equation}
    \mathrm{CNOT} = \pmqty{1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0}.
\end{equation}
CNOT门满足以下恒等式：
\begin{equation}
    C X_1 C = X_1 X_2, \quad C Y_1 C = Y_1 X_2, \quad C Z_1 C = Z_1,
\end{equation}
更加一般的，设$U$是任意一个操作，被单个量子比特控制的\concept{受控$U$门}可以验证为
\begin{equation}
    \pmqty{\dmat{1 & 0 \\ 0 & 1, U}},
\end{equation}
进一步，多量子比特的受控$U$门可以定义为
\begin{equation}
    C^n(U) \ket{x_1, x_2, \ldots, x_n} \ket{\psi} = \ket{x_1, x_2, \ldots, x_n} U^{x_1 x_2 \ldots x_n} \ket{\psi}.
\end{equation}

此外，没有什么要求我们一定要在控制比特为$1$时对目标位做操作，例如完全可以在控制比特为$0$时对目标位做操作。
总之，“在一些量子比特满足某些条件时对另一些量子比特做操作”的量子门统称\concept{广义受控门}。

实际上，二量子比特的一切量子门都可以使用CNOT配合单量子比特门实现实现。
任何一个二量子比特量子门都可以分解为\eqref{eq:abc-decomposition}，而直接代入检验会发现
\begin{equation}
    C(U) = 
\end{equation}
对这个结论的证明实际上和量子线路模型的通用性密切相关，因此我们将在\autoref{sec:universal}中系统地讨论这一点。

\subsubsection{通用量子门}\label{sec:universal}

two level unitary transformation (exact)

任何$d \times d$的幺正变换$U$可以写成$k$个two level unitary的乘积，其中$k \leq d(d-1)/2$。
具体的方法是直接通过

single-qubit and CNOT (exact)

上面提到的量子门的集合都是连续的，这当然也是正确的，因为量子线路模型中可以有相位变换而这是一种连续的操作。
不够还有一种思路是，不要求精确地构造任何可能的幺正变换，而要求可能任意精确地逼近一个幺正变换。这就是近似通用量子门，可以用一个离散的集合做近似通用量子门。例如，

Hadamard, phase, CNOT, T gates (approximate)

使用$\infty$-范数体现两个算符的差异。设

\begin{equation}
    E(R_{\vb*{n}}(\alpha), R_{\vb*{n}}(\theta)^k) < \frac{\epsilon}{3}
\end{equation}

实际上，这种逼近不仅是可能的，还是比较高效的。\concept{Solovay-Kitaev定理}说，通过Hadamard门和T门对任何一个单量子比特门做精度$\epsilon$的近似可以通过最多
\begin{equation}
    N \sim \bigO(\log^c(1/\epsilon))
\end{equation}
个量子门实现，其中$c$大约是$2$。

通用量子门的存在意味着量子电路模型的表现力是非常强大的，可以覆盖任何实际的计算任务。

\subsection{测量}\label{sec:measurement}


\subsubsection{测量一个算符}

设要用投影算符$M_0$和$M_1$做单比特测量，设
\begin{equation}
    M_0 = I + U, \quad M_1 = I - U,
\end{equation}
则

\begin{equation}
    V = (H \otimes I) C(U) (H \otimes I)
\end{equation}

principle of implicit measurement

测量只依赖于子系统的约化密度矩阵，因此自始至终未被测量的量子比特可以当成已经测量的，原因也是显而易见的：
\begin{equation}
    \trace (\hat{\rho}(\hat{E} \otimes \hat{I})) = \trace (\hat{\rho}_A \hat{E}).
\end{equation}
这个结论当然应该是正确的，否则就有信息的超距传播了。

\section{量子算法}

\subsection{量子傅里叶变换}

\subsection{量子相位估计}

\end{document}