\documentclass[hyperref, UTF8, a4paper]{ctexart}

\usepackage{geometry}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{paralist}
\usepackage{footnote}
\usepackage{enumerate}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{bbm}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{physics}
\usepackage{siunitx}
\usepackage{tikz}
\usepackage{autobreak}
\usepackage[ruled, vlined, linesnumbered, noend]{algorithm2e}
\usepackage[colorlinks, linkcolor=black, anchorcolor=black, citecolor=black]{hyperref}
\usepackage{prettyref}

% Page style
\geometry{left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
\titlespacing{\paragraph}{0pt}{1pt}{10pt}[20pt]
\setlength{\droptitle}{-5em}
\preauthor{\vspace{-10pt}\begin{center}}
\postauthor{\par\end{center}}

% Math operators
\DeclareMathOperator{\timeorder}{T}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\legpoly}{P}
\DeclareMathOperator{\primevalue}{P}
\DeclareMathOperator{\sgn}{sgn}
\newcommand*{\ii}{\mathrm{i}}
\newcommand*{\ee}{\mathrm{e}}
\newcommand*{\const}{\mathrm{const}}
\newcommand*{\comment}{\paragraph{注记}}
\newcommand*{\suchthat}{\quad \text{s.t.} \quad}
\newcommand*{\argmin}{\arg\min}
\newcommand*{\argmax}{\arg\max}
\newcommand*{\normalorder}[1]{: #1 :}
\newcommand*{\pair}[1]{\langle #1 \rangle}
\newcommand*{\fd}[1]{\mathcal{D} #1}
\DeclareMathOperator{\bigO}{\mathcal{O}}

% prettyref setting
\newrefformat{sec}{第\ref{#1}节}
\newrefformat{note}{注\ref{#1}}
\newrefformat{fig}{图\ref{#1}}
\newrefformat{alg}{算法\ref{#1}}
\renewcommand{\autoref}{\prettyref}

% TikZ setting
\usetikzlibrary{arrows,shapes,positioning}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.markings}
\tikzstyle arrowstyle=[scale=1]
\tikzstyle directed=[postaction={decorate,decoration={markings,
    mark=at position .5 with {\arrow[arrowstyle]{stealth}}}}]
\tikzstyle ray=[directed, thick]
\tikzstyle dot=[anchor=base,fill,circle,inner sep=1pt]

% Algorithm setting
\renewcommand{\algorithmcfname}{算法}
% Python-style code
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif:}{else:}{}
\SetKwFor{For}{for}{:}{}
\SetKwFor{While}{while}{:}{}
\SetKwInput{KwData}{输入}
\SetKwInput{KwResult}{输出}
\SetArgSty{textnormal}

\renewcommand{\emph}[1]{\textbf{#1}}
\newcommand*{\concept}[1]{\underline{\textbf{#1}}}
\newcommand*{\Ztwo}{$\mathbb{Z}_2$}

\title{量子比特系统和量子逻辑电路}
\author{吴何友}

\begin{document}

\maketitle

\section{量子比特系统}

\subsection{单量子比特}

一个\concept{单量子比特系统}是一个只有$\ket{0}$和$\ket{1}$两种状态的系统。
正如经典比特系统非常简单，但是可以编码一切经典信息，量子比特系统也是量子计算的基础。
单个量子比特也可以看成一个$1/2$自旋自由度，虽然未必有对应的对称性。

量子比特系统的密度矩阵是本征值之和为$1$、本征值大于等于零的全体$2 \times 2$复厄米矩阵，容易验证这样的矩阵一定具有形式
\begin{equation}
    \hat{\rho} = \frac{1 + \vb*{r} \cdot \hat{\vb*{\sigma}}}{2} = \frac{1 + x \hat{\sigma}_x + y \hat{\sigma}_y + z \hat{\sigma}_z}{2}, \quad r = \sqrt{x^2+y^2+z^2} \leq 1.
    \label{eq:bloch-ball}
\end{equation}
这是因为泡利矩阵构成全体$2\times 2$厄米矩阵的一组基，于是一个$2\times 2$厄米矩阵一定可以写成
\[
    R(1 + x \hat{\sigma}_x + y \hat{\sigma}_y + z \hat{\sigma}_z)
\]
的形式。这样的矩阵的本征值为$R(1 \pm r)$，而为了保证本征值之和为$1$必须取$R=1/2$，由本征值大于等于零就有$r\leq 1$，于是就得到\eqref{eq:bloch-ball}。

可以看出，$\vb*{r}$的取值范围构成了一个半径为$1$的球，称为\concept{Bloch球}。
任何密度矩阵都可以表示成Block球上的一个点。
当且仅当密度矩阵只有一个本征值非零时，它对应一个纯态，因此量子比特系统是纯态，当且仅当$r=1$，而$r<1$的情况都是混合态。
实际上，通过计算冯诺依曼熵可以发现$r$越大熵越小，$r=0$时是完全混和态。
于是Bloch球的球壳上是全部纯态，其内部为全部混合态。

既然所有纯态都在Bloch球的球面，不失一般性地，以$z$轴和Bloch球的交点为$\ket{0}$，我们很快会发现$\ket{1}$对应的是$(x, y, z) = (0, 0, -1)$，因此$\ket{0}$在Bloch球的北极，而$\ket{1}$在Bloch球的南极。
显然，$\ket{0}$和$\ket{1}$没有任何特殊地位，因此我们得出结论：Bloch球球面上相对的两个点表示一对正交态。

在Bloch球上建立球坐标系，以$(r, \theta, \varphi)$为球坐标。对$r=1$的点，即纯态，代入\eqref{eq:bloch-ball}，做特征分解可以得到
\begin{equation}
    \ket{\psi(\vb*{r})} = \cos \frac{\theta}{2} \ket{0} + \sin \frac{\theta}{2} \ee^{\ii \varphi} \ket{1},
\end{equation}
而与它正交、位于Bloch球另一边的$\ket{\psi(-\vb*{r})}$是
\begin{equation}
    \ket{\psi(-\vb*{r})} = \sin \frac{\theta}{2} \ket{0} - \cos \frac{\theta}{2} \ee^{\ii \varphi} \ket{1}.
\end{equation}

Bloch球以一种直观的方式展现了量子比特系统和经典比特系统的区别：一个经典比特系统只能够存储\SI{1}{bit}的信息，但是一个量子比特系统需要两个实数来描述，因此包含不可数无穷多个比特的信息。
但是这里有一个微妙的地方：态矢量的分量系数并不是直接可以实验观察的，但一旦做了观测，量子比特系统就坍缩了。
因此我们并不能将$\theta$和$\varphi$直接读出来。

\subsection{多量子比特}

\begin{equation}
    \hat{\rho}_{AB} = \frac{1}{4} (1 + \vb*{a} \cdot \hat{\vb*{\sigma}} \otimes 1_B + 1_A \otimes \vb*{b} \cdot \hat{\vb*{\sigma}} + \sum_{jk} T_{jk} \hat{\sigma}_j \otimes \hat{\sigma}_k ).
\end{equation}

\subsection{量子比特系统的制备}

\section{量子关联}

本节讨论量子比特系统展现出的一些纠缠特性。% TODO:与量子密钥分发之间的关系

\subsection{CHSH游戏}

\subsubsection{隐变量理论的上限}

\subsubsection{量子关联的胜率上限}

\section{量子电路模型}

正如基于经典比特系统的经典逻辑电路可以实现经典计算机，基于量子比特系统的\concept{量子电路}也可以实现量子计算机。
此处“电路”一词并不代表我们使用电子系统实现量子比特，而只是为了和经典构成对比。

一个量子电路模型通常可以分为三步：
\begin{enumerate}
    \item 制备量子态，包括但不限于根据（可能是经典的）输入制备量子比特和引入辅助位；
    \item 幺正演化，即让量子比特经过一系列幺正矩阵（\concept{量子逻辑门}）的变换；
    \item 测量。
\end{enumerate}

\subsection{量子逻辑门}

\subsubsection{单量子比特门}

单比特操作是非常容易实现的，但是显然是不够的，因为多量子比特系统经过单比特操作之后一定会得到直积态，而不能产生纠缠态。

最容易想到的量子门包括泡利矩阵，我们分别用$X, Y, Z$指代三个方向上的泡利矩阵。

\concept{Hadamard门}是指
\begin{equation}
    H = \frac{1}{\sqrt{2}} \pmqty{1 & 1 \\ 1 & -1},
\end{equation}
它可以用于实现态叠加。

\concept{相位门}是指
\begin{equation}
    S = \pmqty{1 & 0 \\ 0 & \ii},
\end{equation}

\concept{T门}或者\concept{$\pi/8$门}
\begin{equation}
    T = \pmqty{1 & 0 \\ 0 & \exp(\ii \pi / 4)}
\end{equation}

我们有以下简单的逻辑门恒等式：
\begin{equation}
    H = (X + Z) / \sqrt{2},
\end{equation}
\begin{equation}
    H X H = Z, \quad H Z H = X, H Y H = - Y.
\end{equation}

现在考虑一些更加高级的逻辑门。我们有\concept{旋转}
\begin{equation}
    R_x(\theta) = \exp(-\frac{\ii \theta X}{2}) = \pmqty{ \cos \frac{\theta}{2} & - \ii \sin \frac{\theta}{2} \\ - \ii \sin \frac{\theta}{2} & \cos \frac{\theta}{2} },
\end{equation}

\begin{equation}
    R_y(\theta) = \exp(-\frac{\ii \theta Y}{2}) = \pmqty{ \cos \frac{\theta}{2} & - \sin \frac{\theta}{2} \\ \sin \frac{\theta}{2} & \cos \frac{\theta}{2} }
\end{equation}
\begin{equation}
    R_z(\theta) = \exp(-\frac{\ii \theta Z}{2}) = 
\end{equation}
实际上，更加一般的，有
\begin{equation}
    R_{\vb*{n}}(\theta) = \cos \frac{\theta}{2} I - \ii \sin \frac{\theta}{2} \vb*{n} \cdot \hat{\vb*{\sigma}}.
\end{equation}
可以证明，任何一个单比特幺正变换均形如
\begin{equation}
    U = \ee^{\ii \alpha} R_z(\beta) R_y(\gamma) R_z(\delta).
\end{equation}

\subsubsection{二量子比特门}

最为平凡的二量子比特门可能是两个单量子比特门直积得到的（注意张量积不可交换，虽然$A \otimes B \simeq B \otimes A$）。
稍微复杂一些的二量子比特门是所谓\concept{受控操作}，如CNOT：
\begin{equation}
    \mathrm{CNOT} = \pmqty{1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0}.
\end{equation}
CNOT门满足以下恒等式：
\begin{equation}
    C X_1 C = X_1 X_2, \quad C Y_1 C = Y_1 X_2, \quad C Z_1 C = Z_1,
\end{equation}

更加一般的，设$U$是任意一个操作，可以定义被单个量子比特控制的\concept{受控$U$门}为
\begin{equation}
    \pmqty{\dmat{1 & 0 \\ 0 & 1, U}},
\end{equation}
进一步，多量子比特的受控$U$门可以定义为
\begin{equation}
    C^n(U) \ket{x_1, x_2, \ldots, x_n} \ket{\psi} = \ket{x_1, x_2, \ldots, x_n} U^{x_1 x_2 \ldots x_n} \ket{\psi}.
\end{equation}
多量子比特的受控$U$门可以使用

\end{document}