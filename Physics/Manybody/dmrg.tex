\documentclass[hyperref, UTF8, a4paper]{ctexart}

\usepackage{geometry}
\usepackage{titling}
\usepackage{titlesec}
\usepackage{paralist}
\usepackage{footnote}
\usepackage{enumerate}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{bbm}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{physics}
\usepackage{tikz}
\usepackage{autobreak}
\usepackage[ruled, vlined, linesnumbered, noend]{algorithm2e}
\usepackage[colorlinks, linkcolor=black, anchorcolor=black, citecolor=black]{hyperref}
\usepackage{prettyref}

% Page style
\geometry{left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
\titlespacing{\paragraph}{0pt}{1pt}{10pt}[20pt]
\setlength{\droptitle}{-5em}
\preauthor{\vspace{-10pt}\begin{center}}
\postauthor{\par\end{center}}

% Math operators
\DeclareMathOperator{\timeorder}{T}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\legpoly}{P}
\DeclareMathOperator{\primevalue}{P}
\DeclareMathOperator{\sgn}{sgn}
\newcommand*{\ii}{\mathrm{i}}
\newcommand*{\ee}{\mathrm{e}}
\newcommand*{\const}{\mathrm{const}}
\newcommand*{\comment}{\paragraph{注记}}
\newcommand*{\suchthat}{\quad \text{s.t.} \quad}
\newcommand*{\argmin}{\arg\min}
\newcommand*{\argmax}{\arg\max}
\newcommand*{\normalorder}[1]{: #1 :}
\newcommand*{\pair}[1]{\langle #1 \rangle}
\newcommand*{\fd}[1]{\mathcal{D} #1}
\DeclareMathOperator{\bigO}{\mathcal{O}}

% prettyref setting
\newrefformat{sec}{第\ref{#1}节}
\newrefformat{note}{注\ref{#1}}
\newrefformat{fig}{图\ref{#1}}
\newrefformat{alg}{算法\ref{#1}}
\renewcommand{\autoref}{\prettyref}

% TikZ setting
\usetikzlibrary{arrows,shapes,positioning}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{decorations.markings}
\tikzstyle arrowstyle=[scale=1]
\tikzstyle directed=[postaction={decorate,decoration={markings,
    mark=at position .5 with {\arrow[arrowstyle]{stealth}}}}]
\tikzstyle ray=[directed, thick]
\tikzstyle dot=[anchor=base,fill,circle,inner sep=1pt]

% Algorithm setting
\renewcommand{\algorithmcfname}{算法}
% Python-style code
\SetKwIF{If}{ElseIf}{Else}{if}{:}{elif:}{else:}{}
\SetKwFor{For}{for}{:}{}
\SetKwFor{While}{while}{:}{}
\SetKwInput{KwData}{输入}
\SetKwInput{KwResult}{输出}
\SetArgSty{textnormal}

\renewcommand{\emph}[1]{\textbf{#1}}
\newcommand*{\concept}[1]{{\textbf{#1}}}

\title{密度矩阵重整化群和张量网络}
\author{吴何友}

\begin{document}

\maketitle

\section{张量网络}

本文所谓的张量一般不具有微分几何上的意义，仅仅保留缩并等规则。

任何一个统计模型都可以写成一个张量网络，

\begin{equation}
    E = \sum_{\pair{i, j}} \left( - J \sigma_i \sigma_j - \frac{h}{2} \sigma_i - \frac{h}{2} \sigma_j \right).
\end{equation}

把格点自由度放在张量网络的边上。

DMRG = Density-Matrix Renormalization Group

模拟一个一般的量子系统是非常困难的，因为希尔伯特空间比经典力学的相空间要大得多。设系统中有$N$个动力学自由度，相空间是一个$N$维空间，而希尔伯特空间则是一个维度为$2^N$量级的空间。使用诸如严格对角化之类的方式，内存会很快耗尽。
好消息是，我们通常会遇到的系统都有一些性质，保证了它们的量子态其实只会取整个希尔伯特空间中很小的一部分。
在平均场理论中，我们用一个序参量把相互作用项变成了自由项，因此系统的态矢量仅限于直积态，没有任何纠缠。实际的系统当然不会这么简单，但是实际上将直积态做一个简单的推广就可以得到很好的结果。本文将介绍一种这样的推广：\concept{矩阵乘积态（MPS）}。

左、右正规形式，调整正交中心，SVD，最后得到一个施密特分解，然后发现能够表示的最大的纠缠熵为$\ln D$。因此纠缠非常厉害的态不能使用MPS表示。

一维玻色子系统在有能隙的情况下，服从perimeter law，因此纠缠熵大体上是一个常数，所以只需要把$D$设置得足够大，就可以模拟。
一维无能隙玻色子系统的纠缠熵大体上正比于$\ln L$，于是$D \sim L$，因此在规模不大时可以计算，规模大了就不行。
二维系统就比较麻烦了，纠缠熵正比于$L y$，于是

通过将哈密顿量写成一个自动机，可以将哈密顿量也写成矩阵乘积，为所谓MPO。



\end{document}