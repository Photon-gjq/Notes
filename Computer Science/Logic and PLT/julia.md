# 类型系统

## 子类型的必要性

子类型在纯粹的类型论研究中是比较讨厌的一个东西，因为它不能像其它常见feature一样，通过一个引入规则和一个消去规则非常干脆利落、和其它feature确定正交地被引入。
但在一些情况下子类型是非常有用的。Julia的类型系统可以算是一个例子。多重派发机制显然要求能够有一个比较符合直觉的方式决定一个函数调用发生时哪一份代码被执行，而子类型产生的类型树显然是一个非常方便的选择。

实际上，Julia的子类型机制也就仅仅满足这个目标而已：具体类型不能够以具体类型为父类型，即所有的具体类型都是final的。
这样一方面可以为多重派发提供方便，一方面可以尽可能避免各种subtle的细节。

## “动态性”、运行时模板和多重派发

Julia可以被看成动态语言被阉割掉一部分动态性的产物，也可以看成往静态语言中embed少量动态性的产物。

Julia的“类型”实际上同时出现在两个地方：一个是运行时对值的标注，“类型”（或者说“tag”）可以被像普通的值一样传递和处理，如果单纯考虑这种“类型”，那其实就是标准的动态类型语言，和Python等完全没有区别，我们可以把这样一个语言很容易地embed进一个静态强类型语言中，只需要让所有值都是`Dynamic<Representation, Tag>`类型的即可；一个是变量类型声明（`a::T`）、类型定义（定义`struct`等），这些东西写起来很像静态类型语言。两种“类型”是打通的。

### 运行时的多重派发

为了简化代码编写，我们需要允许不同的函数共享一个名称。其结果是，当一个函数调用出现时，需要有某个机制来决定运行哪一份代码。Julia中通常将共用一个名字的不同函数称为不同的“方法”。也即，需要有一个机制将一个函数调用派发到特定的方法上。

Julia通过多重派发满足这个需求。多重派发实际上是运行时的模板机制。如果一个方法的所有参数的类型都是具体类型，那么对它的调用和静态语言中没有任何区别。反之，如果一个方法有参数是抽象类型，那么它实际上是一个模板函数，因为实际会传给这个方法的任何值都有完全确定的类型且一定是具体类型；这个有参数是抽象类型的方法被调用时的行为仍然不是完全确定的，而取决于传给该方法的值的具体类型，因为该方法的内部实现会触发另一次多重派发（例如，考虑一个抽象的`sum`函数：它的内部会调用`+`操作，而编译期我们并不知道这个`+`操作会被派发到哪一个方法上面）。

可以看到多重派发实际上引入了动态性。
在这里动态性是确实存在的，而不仅仅是强大的类型推导造成的幻觉：例如，可以在Julia中写出这样的函数，它根据输入值的不同，产生不同类型的输出值（例如，如果输入值是ATGC四个字母组成的字符串那么输出一个表示DNA序列的结构体，否则输出原本的字符串），这不会造成任何错误，因为没有发生“对值进行操作时发现这个值的类型不支持对应的操作”。
但是这种动态性与完全的动态语言又不一样——一段程序最终会转化为对基本操作（加减乘除等）的调用，在完全的动态语言中，只有一个“+”，它内部也许会根据输入的操作数的类型不同选择不同的处理流程，也许会有数据类型转化，而在Julia中，有好多个完全指定了操作数的类型的“+”，在“a+b”形式的表达式被求值时，调用哪一个加法由多重派发机制自动决定。

### 与纯粹的静态语言的不同之处

Julia的多重派发机制相比普通的模板机制使用起来更加方便，因为很多时候无需手动指定类型参数，多重派发会自动找到应该调用的方法。
不过，普通的模板机制配合上足够强大的类型推导也可以做到这一点。
这两者本质的差别在于Julia的动态性：在编译期，一个函数调用会调用哪一个方法在静态类型语言中是完全确定的，而在Julia中则不是这样，也即，模板展开可能是在运行期进行的。
例如，`sum`函数可能是一个模板函数，读入一个可以相加的类型，输出一个具体的求和函数（或者说，所有参数的类型都是具体类型的方法），在静态类型语言中，类型推导意味着我们可以写`sum(arr)`而不显式给出类型参数的值，但是为了正确推导类型，`arr`的类型必须要知道；当然，也许`arr`的类型也没有显式声明，但是生成`arr`的子程序的返回类型必须要知道……这样一路向前追溯，最终必须能够追溯到一些类型常量，只有这样才能够在编译期将所有的类型确定下来。
反之，在Julia中，完全可以写出诸如这样的代码：从一个文件读入一个序列，根据这个序列中的数有没有小数点决定是把它转化为一个`Array{Int64}`还是一个`Array{Float64}`，然后传给`sum`求和。
换句话说，`sum`直到运行期都保持模板函数的特性，只有当一个`Array{Int64}`或是一个`Array{Float64}`被传入时才决定执行哪个版本。
（这种动态性同样意味着类型tag应该能够在运行时被提取、处理，这也就是Julia中类型也是对象的原因）

### 对动态性的限制

另一方面，相比于完全的动态语言，Julia也有一些事情是不能做的。一个完全的动态语言应该允许这样的操作：定义一个函数，读入一个未知的数据，然后动态地产生一个`struct`。
这在Julia中是不被允许的。这也就是需要在`(args)`之外再引入`{args}`的原因之一。
大部分的模板函数的类型参数都可以作为普通的`(args)`参数传入，但这可能拖慢效率，而模板结构体则必须要用`{args}`。

# 宏

Julia具有非常像Lisp的宏。主要的不同之处在于Julia宏操作的AST的格式并非S expression那种`(+ 1 2)`型的，而是由`Symbol`, `Expr`等类型的对象组成的；分号用`LineNumberNode`表示。